(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{993:function(t,v,_){"use strict";_.r(v);var a=_(28),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http-协议的主要特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-协议的主要特点"}},[t._v("#")]),t._v(" HTTP 协议的主要特点")]),t._v(" "),_("ul",[_("li",[t._v("简单快速")])]),t._v(" "),_("p",[t._v("每个资源的 URI 都是固定的，客户向服务器请求服务时，只需传送请求方法和路径。")]),t._v(" "),_("ul",[_("li",[t._v("灵活")])]),t._v(" "),_("p",[t._v("HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。")]),t._v(" "),_("ul",[_("li",[t._v("无连接")])]),t._v(" "),_("p",[t._v("无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。")]),t._v(" "),_("ul",[_("li",[t._v("无状态")])]),t._v(" "),_("p",[t._v("HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。")]),t._v(" "),_("h2",{attrs:{id:"http-报文的组成部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-报文的组成部分"}},[t._v("#")]),t._v(" HTTP 报文的组成部分")]),t._v(" "),_("p",[t._v("请求报文由请求行、请求头、空行、请求体组成。")]),t._v(" "),_("p",[t._v("响应报文由状态行、响应头、空行、响应体组成。")]),t._v(" "),_("h2",{attrs:{id:"http-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-方法"}},[t._v("#")]),t._v(" HTTP 方法")]),t._v(" "),_("p",[t._v("GET 获取资源")]),t._v(" "),_("p",[t._v("POST 传输资源")]),t._v(" "),_("p",[t._v("PUT 更新资源")]),t._v(" "),_("p",[t._v("DELETE 删除资源")]),t._v(" "),_("p",[t._v("HEAD 获得报文首部")]),t._v(" "),_("h2",{attrs:{id:"post-和-get-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#post-和-get-的区别"}},[t._v("#")]),t._v(" POST 和 GET 的区别")]),t._v(" "),_("ul",[_("li",[t._v("GET 在浏览器回退时是无害的，POST 会再次提交请求。")]),t._v(" "),_("li",[t._v("GET 产生的 URL 地址可以被收藏，POST 不可以。")]),t._v(" "),_("li",[t._v("GET 请求会被浏览器主动缓存，POST 不会，除非手动设置。")]),t._v(" "),_("li",[t._v("GET 请求只能进行 URL 编码，POST 支持多种编码方式。")]),t._v(" "),_("li",[t._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。")]),t._v(" "),_("li",[t._v("GET 请求在 URL 中传送的参数是有长度限制的，POST 没有限制。")]),t._v(" "),_("li",[t._v("对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。")]),t._v(" "),_("li",[t._v("GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。")]),t._v(" "),_("li",[t._v("GET 参数通过 URL 传递，POST 放在 Request body 中。")])]),t._v(" "),_("p",[t._v("上面的东西如果不好记忆，可以从工作理解：")]),t._v(" "),_("ol",[_("li",[t._v("get 请求的参数一般放在url里面，post 请求的参数放在请求体里面。")]),t._v(" "),_("li",[t._v("get 请求可以被浏览器缓存，post 请求不能被缓存")]),t._v(" "),_("li",[t._v("get 请求长度在浏览器中有限制，post 请求长度没有限制")]),t._v(" "),_("li",[t._v("get 请求的安全性相对差点，post 请求相对安全点")]),t._v(" "),_("li",[t._v("get 请求可以通过浏览器直接访问，post 请求不能通过浏览器直接访问")])]),t._v(" "),_("h2",{attrs:{id:"http-状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[t._v("#")]),t._v(" HTTP 状态码")]),t._v(" "),_("ul",[_("li",[t._v("1xx：指示信息 - 表示请求已经收到，继续处理。")]),t._v(" "),_("li",[t._v("2xx：成功 - 表示请求已被成功接收\n"),_("ul",[_("li",[t._v("200 ok：客户端请求成功")])])]),t._v(" "),_("li",[t._v("3xx：重定向 - 要完成请求必须进行更进一步的操作。\n"),_("ul",[_("li",[t._v("301 永久重定向：所有请求页面已经转移至新的 url")]),t._v(" "),_("li",[t._v("302 临时重定向：所有请求已临时转移至新的 url")]),t._v(" "),_("li",[t._v("304 Not Modified：客户端有缓存的文档并发出了一个条件性的请求，服务器告诉客户端原来缓存的文档可以继续使用。")])])]),t._v(" "),_("li",[t._v("4xx：客户端错误 - 请求有语法错误或请求无法实现。\n"),_("ul",[_("li",[t._v("400 Bad Request：客户端请求有语法错误，不能被服务器理解。")]),t._v(" "),_("li",[t._v("401 Unauthorized：请求为授权")]),t._v(" "),_("li",[t._v("403 Forbidden： 资源禁止被访问")]),t._v(" "),_("li",[t._v("404 Not Found：请求资源不存在")])])]),t._v(" "),_("li",[t._v("5xx：服务器错误 - 服务器未能实现合法的请求。\n"),_("ul",[_("li",[t._v("500 Internal Server Error：服务器发生不可预期的错误原来缓存的文档还可以继续使用。")]),t._v(" "),_("li",[t._v("503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常。")])])])]),t._v(" "),_("h2",{attrs:{id:"什么是持久连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是持久连接"}},[t._v("#")]),t._v(" 什么是持久连接")]),t._v(" "),_("p",[t._v("HTTP1.1版本支持持久连接。")]),t._v(" "),_("p",[t._v("HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 keep-alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）。")]),t._v(" "),_("p",[t._v("当使用 keep-alive 模式（又称持久连接、连接重用）时， keep-alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，keep-alive 功能避免了建立或者重新建立连接。")]),t._v(" "),_("h2",{attrs:{id:"什么是管线化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是管线化"}},[t._v("#")]),t._v(" 什么是管线化")]),t._v(" "),_("p",[t._v("在使用持久连接的情况下，某个连接上消息的传递类似于：请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3 。。。。")]),t._v(" "),_("p",[t._v("开启管线化后，某个连接上的消息变成了类似这样：请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3 。")]),t._v(" "),_("ul",[_("li",[t._v("管线化机制通过持久连接完成，仅 HTTP1.1 支持此技术。")]),t._v(" "),_("li",[t._v("只有 GET 和 HEAD 请求可以进行管线化，POST 则有所限制。")]),t._v(" "),_("li",[t._v("初次创建连接时不应启动管线化机制，因为服务器不一定支持HTTP1.1版本的协议。")]),t._v(" "),_("li",[t._v("管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变。")]),t._v(" "),_("li",[t._v("HTTP1.1要求服务端支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可。")]),t._v(" "),_("li",[t._v("由于上面提到的服务端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和Firefox 默认并未开启管线化支持。")])]),t._v(" "),_("h2",{attrs:{id:"http2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" http2")]),t._v(" "),_("h2",{attrs:{id:"http的内容是如何窃听的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http的内容是如何窃听的"}},[t._v("#")]),t._v(" http的内容是如何窃听的")]),t._v(" "),_("h2",{attrs:{id:"对称加密和非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密"}},[t._v("#")]),t._v(" 对称加密和非对称加密")]),t._v(" "),_("h2",{attrs:{id:"对称加密和非对称加密怎么选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密怎么选择"}},[t._v("#")]),t._v(" 对称加密和非对称加密怎么选择")]),t._v(" "),_("h2",{attrs:{id:"浏览器怎么验证证书"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器怎么验证证书"}},[t._v("#")]),t._v(" 浏览器怎么验证证书")]),t._v(" "),_("h2",{attrs:{id:"cdn缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cdn缓存"}},[t._v("#")]),t._v(" cdn缓存")]),t._v(" "),_("p",[t._v("loader和plugin的区别；\n前端模块化；\n浏览器的本地存储；\n同源策略；跨域的解决方式；\n前端性能优化；\nhttp如何实现缓存；✔️\nhttp状态码；✔️\nGet和Post的区别；✔️\nhttp和https的区别；\nTCP和UDP的区别；\nH5新特性和新标签；\nasync和defer的区别；")]),t._v(" "),_("p",[t._v("keep-alive的实现；")]),t._v(" "),_("p",[t._v("头条：\n说下EventLoop；\nCommonJS和ES Module的区别；")]),t._v(" "),_("p",[t._v("DNS预解析怎么实现的；\n为什么要用http2;\nhttp1.1和http2的区别；\n浏览器怎么验证证书；\nhttp的内容是如何窃听的；\n对称加密和非对称加密；\n对称加密和非对称加密怎么选择；\ncdn缓存；\nhttps握手过程；\n模块热替换的原理；\nwebpack是怎么实现的；\nplugins作用于webapck的哪个生命周期；\n你所知道的白屏原因；\nflex：1；\nIEEE754；\nTCP拥塞控制；kdk\nTCP和UDP的区别；\n三次挥手四次握手；\ndevServe做了哪些优化；")]),t._v(" "),_("p",[t._v("Server push；\nsession；\nJwt;\nCSRF；")])])}),[],!1,null,null,null);v.default=e.exports}}]);