(window.webpackJsonp=window.webpackJsonp||[]).push([[477],{1284:function(t,s,n){"use strict";n.r(s);var a=n(28),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("ES6 Module")]),t._v(" "),n("p",[t._v("不同于CommonJS和AMD的模块加载翻噶嘛，ES6在JS语言层面上实现了模块功能。它的设计思想是:尽量的静态化，使得编译时就能确定模块的依赖关系。在遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到的时候，再到模块里面去取值。这和CommonJS模块规范的最大不同。")]),t._v(" "),n("p",[t._v("webpack会对node_modules里的依赖做什么？")]),t._v(" "),n("p",[t._v("webpack会根据定义的引入方式判断模块类型，再进行相关编译转化。当使用import引入时，babel默认会把ES6的模块转化成CommonJS规范，然后会将node_module里的依赖打包成自执行函数的样式")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("modules")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//执行逻辑")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("模块数组"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[t._v("在模块数组中将模块传入，在函数体中经过一系列操作最终将模块通过module.exports导出")])])}),[],!1,null,null,null);s.default=e.exports}}]);