(window.webpackJsonp=window.webpackJsonp||[]).push([[382],{1174:function(v,_,l){"use strict";l.r(_);var i=l(28),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[v._v("本文为阅读掘金作者修言的 "),l("a",{attrs:{href:"https://juejin.cn/book/6844733790204461070",target:"_blank",rel:"noopener noreferrer"}},[v._v("<<JavaScript设计模式核心原理与应用实践>>"),l("OutboundLink")],1),v._v("的笔记和感悟，作者写作不易，阅读小册请支持正版。")]),v._v(" "),l("div",{staticClass:"custom-block tip"},[l("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),l("p",[v._v("基础理论知识是一个人的基线，理论越强基线越高。再为自己定一个目标和向上攀附的阶梯，那么达到目标就是时间问题，而很多野路子工程师搞了半辈子也未达到优秀工程师的基线，很多他们绞尽脑汁得出的高深学问，不过是正规工程师看起来很自然的东西。—— 吴军")])]),v._v(" "),l("p",[v._v("目前前端并不缺用各种框架、语法去写 hello world 的人，缺的是能驾驭这个框架、语法，凭借自己深刻的架构思想和工程思想支配这个框架，创造牛逼产出的人。")]),v._v(" "),l("p",[v._v("驾驭技术的能力分为三层，层层递进：")]),v._v(" "),l("ul",[l("li",[v._v("能用健壮的代码去解决具体的问题；")]),v._v(" "),l("li",[v._v("能用抽象的思维去应对复杂的系统；")]),v._v(" "),l("li",[v._v("能用工程化的思想去规划更大规模的业务；")])]),v._v(" "),l("p",[v._v("针对第一层所对标的经典知识体系就是设计模式。")]),v._v(" "),l("p",[v._v("设计模式的核心思想是封装变化，设计模式的核心操作是去观察整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。")]),v._v(" "),l("p",[v._v("设计原则是设计模式的指导理论，SOLID 指代的五个基本原则分别是：")]),v._v(" "),l("ul",[l("li",[v._v("单一功能原则（Single Responsibility Principle）")]),v._v(" "),l("li",[v._v("开放封闭原则（Opened Closed Principle）")]),v._v(" "),l("li",[v._v("里式替换原则（Liskov Substitution Principle）")]),v._v(" "),l("li",[v._v("接口隔离原则（Interface Segregation Principle）")]),v._v(" "),l("li",[v._v("依赖反转原则（Dependency Inversion Principle）")])]),v._v(" "),l("p",[v._v("在 JS 设计模式中主要用到的设计模式基本都围绕 ”单一功能“ 和 ”开放封闭“ 展开。")]),v._v(" "),l("p",[v._v("《设计模式：可复用面向对象软件的基础》这本书将23种设计模式按照“创建型”、“行为型”和“结构型”进行划分：")]),v._v(" "),l("ul",[l("li",[v._v("创建型\n"),l("ul",[l("li",[v._v("单例模式")]),v._v(" "),l("li",[v._v("原型模式")]),v._v(" "),l("li",[v._v("构造器模式")]),v._v(" "),l("li",[v._v("工厂模式")]),v._v(" "),l("li",[v._v("抽象工厂模式")])])]),v._v(" "),l("li",[v._v("结构型\n"),l("ul",[l("li",[v._v("桥接模式")]),v._v(" "),l("li",[v._v("外观模式")]),v._v(" "),l("li",[v._v("组合模式")]),v._v(" "),l("li",[v._v("装饰器模式")]),v._v(" "),l("li",[v._v("适配器模式")]),v._v(" "),l("li",[v._v("代理模式")]),v._v(" "),l("li",[v._v("享元模式")])])]),v._v(" "),l("li",[v._v("行为型\n"),l("ul",[l("li",[v._v("迭代器模式")]),v._v(" "),l("li",[v._v("解释器模式")]),v._v(" "),l("li",[v._v("观察者模式")]),v._v(" "),l("li",[v._v("中介者模式")]),v._v(" "),l("li",[v._v("访问者模式")]),v._v(" "),l("li",[v._v("状态模式")]),v._v(" "),l("li",[v._v("备忘录模式")]),v._v(" "),l("li",[v._v("策略模式")]),v._v(" "),l("li",[v._v("模板方法模式")]),v._v(" "),l("li",[v._v("职责链模式")]),v._v(" "),l("li",[v._v("命令模式")])])])]),v._v(" "),l("p",[v._v("这里并不会对所有的设计模式都进行介绍，只介绍前端有迫切需求的几种。")])])}),[],!1,null,null,null);_.default=e.exports}}]);